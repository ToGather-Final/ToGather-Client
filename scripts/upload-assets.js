#!/usr/bin/env node

/**
 * ‚úÖ ÏïàÏ†ïÌòï Next.js Ï†ïÏ†Å ÏûêÏÇ∞ ÏóÖÎ°úÎçî
 * - .next/static Ï†ÑÏ≤¥Î•º Îã®Ïùº ÏóÖÎ°úÎìú (Ï§ëÎ≥µ Ï†úÍ±∞)
 * - ÎπåÎìú ÏôÑÎ£å ÌõÑÏóêÎßå Ïã§Ìñâ (ÏÇ¨Ï†Ñ Ï°¥Ïû¨ ÌôïÏù∏)
 * - ÏßÅÎ†¨ ÏóÖÎ°úÎìúÎ°ú ÎàÑÎùΩ Î∞©ÏßÄ
 * - CloudFront Î¨¥Ìö®Ìôî ÏûêÎèô Ïã§Ìñâ
 */

const {
    S3Client,
    PutObjectCommand,
    ListObjectsV2Command,
    DeleteObjectCommand,
} = require("@aws-sdk/client-s3");
const {
    CloudFrontClient,
    CreateInvalidationCommand,
} = require("@aws-sdk/client-cloudfront");
const fs = require("fs");
const path = require("path");
const mime = require("mime-types");

const REGION = "ap-northeast-2";
const BUCKET_NAME = process.env.S3_BUCKET_NAME || "togather-static-assets";
const CLOUDFRONT_DISTRIBUTION_ID =
    process.env.CLOUDFRONT_DISTRIBUTION_ID || "E15ZDIW40YBVEN";

const s3Client = new S3Client({ region: REGION });
const cloudfrontClient = new CloudFrontClient({ region: REGION });

function sleep(ms) {
    return new Promise((r) => setTimeout(r, ms));
}

function getAllFiles(dirPath, fileList = []) {
    const files = fs.readdirSync(dirPath);
    for (const file of files) {
        const full = path.join(dirPath, file);
        if (fs.statSync(full).isDirectory()) {
            getAllFiles(full, fileList);
        } else {
            fileList.push(full);
        }
    }
    return fileList;
}

async function uploadFile(filePath, baseDir, prefix = "") {
    const relative = path.relative(baseDir, filePath).replace(/\\/g, "/");
    const s3Key = prefix ? `${prefix}/${relative}` : relative;
    const contentType = mime.lookup(filePath) || "application/octet-stream";
    const fileContent = fs.readFileSync(filePath);

    const cacheControl =
        filePath.includes("_next/static/") ||
        filePath.match(/\.(jpg|jpeg|png|gif|webp|svg|woff2?)$/)
            ? "public, max-age=31536000, immutable"
            : "public, max-age=3600";

    try {
        await s3Client.send(
            new PutObjectCommand({
                Bucket: BUCKET_NAME,
                Key: s3Key,
                Body: fileContent,
                ContentType: contentType,
                CacheControl: cacheControl,
            })
        );
        console.log(`‚úÖ Uploaded: ${s3Key}`);
    } catch (err) {
        console.error(`‚ùå Failed: ${s3Key} (${err.message})`);
    }
}

async function uploadDirectory(localDir, s3Prefix = "") {
    console.log(`üì¶ Uploading directory: ${localDir}`);
    const files = getAllFiles(localDir);
    console.log(`üìÅ Found ${files.length} files`);
    for (const file of files) {
        await uploadFile(file, localDir, s3Prefix);
    }
    console.log("‚úÖ Upload complete");
}

async function invalidateCloudFront() {
    console.log("üîÑ Invalidating CloudFront cache...");
    const cmd = new CreateInvalidationCommand({
        DistributionId: CLOUDFRONT_DISTRIBUTION_ID,
        InvalidationBatch: {
            CallerReference: `deploy-${Date.now()}`,
            Paths: { Quantity: 1, Items: ["/*"] },
        },
    });
    const res = await cloudfrontClient.send(cmd);
    console.log(`‚úÖ Invalidation started: ${res.Invalidation.Id}`);
}

async function clearS3Bucket() {
    console.log("üßπ Clearing S3 bucket before upload...");
    let totalDeleted = 0;
    let continuationToken = undefined;
    
    try {
        do {
            const listCommand = new ListObjectsV2Command({
                Bucket: BUCKET_NAME,
                Prefix: "_next/",
                MaxKeys: 1000, // Ìïú Î≤àÏóê ÏµúÎåÄ 1000Í∞ú
                ContinuationToken: continuationToken
            });
            
            const listResult = await s3Client.send(listCommand);
            
            if (listResult.Contents && listResult.Contents.length > 0) {
                console.log(`üóëÔ∏è Deleting ${listResult.Contents.length} files (batch)...`);
                
                // Î≥ëÎ†¨ ÏÇ≠Ï†úÎ°ú ÏÜçÎèÑ Ìñ•ÏÉÅ
                const deletePromises = listResult.Contents.map(async (object) => {
                    try {
                        const deleteCommand = new DeleteObjectCommand({
                            Bucket: BUCKET_NAME,
                            Key: object.Key
                        });
                        await s3Client.send(deleteCommand);
                        console.log(`  ‚úÖ Deleted: ${object.Key}`);
                        return true;
                    } catch (deleteErr) {
                        console.error(`  ‚ùå Failed to delete ${object.Key}:`, deleteErr.message);
                        return false;
                    }
                });
                
                const results = await Promise.all(deletePromises);
                const successCount = results.filter(r => r).length;
                totalDeleted += successCount;
                
                if (successCount < listResult.Contents.length) {
                    console.warn(`‚ö†Ô∏è ${listResult.Contents.length - successCount} files failed to delete`);
                }
            }
            
            // Îã§Ïùå ÌéòÏù¥ÏßÄÍ∞Ä ÏûàÎäîÏßÄ ÌôïÏù∏
            continuationToken = listResult.NextContinuationToken;
            
        } while (continuationToken);
        
        console.log(`‚úÖ S3 bucket cleared successfully! Deleted ${totalDeleted} files total.`);
        
    } catch (err) {
        console.error("‚ùå Failed to clear S3 bucket:", err.message);
        console.warn("‚ö†Ô∏è Continuing with upload despite clear failure...");
        // ÏÇ≠Ï†ú Ïã§Ìå®Ìï¥ÎèÑ ÏóÖÎ°úÎìúÎäî Í≥ÑÏÜç ÏßÑÌñâ
    }
}

async function main() {
    console.log("üöÄ Starting static asset deployment...");
    const nextDir = path.join(__dirname, "..", ".next");
    const staticDir = path.join(nextDir, "static");
    const publicDir = path.join(__dirname, "..", "public");

    // 1Ô∏è‚É£ ÎπåÎìú ÏôÑÎ£å ÎåÄÍ∏∞ (.next/static/chunks Ï°¥Ïû¨Ìï¥Ïïº Ìï®)
    let retries = 0;
    while (!fs.existsSync(staticDir) && retries < 5) {
        console.log("‚è≥ Waiting for .next/static to be ready...");
        await sleep(2000);
        retries++;
    }

    if (!fs.existsSync(staticDir)) {
        throw new Error("‚ùå .next/static ÎîîÎ†âÌÜ†Î¶¨Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§. ÎπåÎìú Ïã§Ìå®Î°ú Ï∂îÏ†ïÎê©ÎãàÎã§.");
    }

    // 2Ô∏è‚É£ Í∏∞Ï°¥ S3 ÌååÏùº Ï†ïÎ¶¨ (ÏÑ†ÌÉùÏÇ¨Ìï≠)
    await clearS3Bucket();

        // 3Ô∏è‚É£ .next/static Ï†ÑÏ≤¥ ÏóÖÎ°úÎìú
        console.log("üîç Uploading .next/static files...");
        console.log("üìÅ Static directory contents:");
        const staticFiles = getAllFiles(staticDir);
        console.log(`Found ${staticFiles.length} files in .next/static`);
        
        // main-app ÌååÏùºÎì§ ÌôïÏù∏
        const mainAppFiles = staticFiles.filter(f => f.includes('main-app'));
        console.log("üìã main-app files found:", mainAppFiles.map(f => path.basename(f)));
        
        await uploadDirectory(staticDir, "_next/static");

        // 4Ô∏è‚É£ stock Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú
        console.log("üñºÔ∏è Uploading stock images...");
        const stockImagesDir = path.join(process.cwd(), "public", "images", "stock");
        if (fs.existsSync(stockImagesDir)) {
            const stockFiles = getAllFiles(stockImagesDir);
            console.log(`Found ${stockFiles.length} stock image files`);
            
            for (const file of stockFiles) {
                const relativePath = path.relative(stockImagesDir, file);
                const s3Key = `images/stock/${relativePath}`;
                await uploadFile(file, stockImagesDir, "images/stock");
                console.log(`‚úÖ Uploaded stock image: ${s3Key}`);
            }
        } else {
            console.log("‚ö†Ô∏è Stock images directory not found, skipping...");
        }

        // 5Ô∏è‚É£ Î°úÍ≥† Î∞è ÌååÎπÑÏΩò ÏóÖÎ°úÎìú
        console.log("üé® Uploading logos and favicons...");
        const logoFiles = [
            'logo.png',
            'logo.webp', 
            'logo_blue.png',
            'favicon.ico'
        ];
        
        for (const logoFile of logoFiles) {
            const logoPath = path.join(process.cwd(), "public", logoFile);
            if (fs.existsSync(logoPath)) {
                await uploadFile(logoPath, path.join(process.cwd(), "public"), "");
                console.log(`‚úÖ Uploaded logo/favicon: ${logoFile}`);
            } else {
                console.log(`‚ö†Ô∏è Logo file not found: ${logoFile}`);
            }
        }

        // 6Ô∏è‚É£ images/ PNG ÌååÏùºÎì§ ÏóÖÎ°úÎìú (stock Ìè¥Îçî Ï†úÏô∏)
        console.log("üñºÔ∏è Uploading images/ PNG files (excluding stock)...");
        const imagesDir = path.join(process.cwd(), "public", "images");
        if (fs.existsSync(imagesDir)) {
            const allFiles = getAllFiles(imagesDir);
            const pngFiles = allFiles.filter(file => 
                file.endsWith('.png') && 
                !file.includes('stock/') // stock Ìè¥Îçî Ï†úÏô∏
            );
            
            console.log(`Found ${pngFiles.length} PNG files in images/ (excluding stock)`);
            
            for (const file of pngFiles) {
                const relativePath = path.relative(imagesDir, file);
                await uploadFile(file, imagesDir, "images");
                console.log(`‚úÖ Uploaded PNG image: images/${relativePath}`);
            }
        } else {
            console.log("‚ö†Ô∏è Images directory not found, skipping...");
        }

        // 7Ô∏è‚É£ Ìè∞Ìä∏ ÌååÏùºÎì§ ÏóÖÎ°úÎìú
        console.log("üî§ Uploading font files...");
        const fontsDir = path.join(process.cwd(), "public", "fonts");
        if (fs.existsSync(fontsDir)) {
            const fontFiles = getAllFiles(fontsDir);
            console.log(`Found ${fontFiles.length} font files`);
            
            for (const file of fontFiles) {
                const relativePath = path.relative(fontsDir, file);
                await uploadFile(file, fontsDir, "fonts");
                console.log(`‚úÖ Uploaded font: fonts/${relativePath}`);
            }
        } else {
            console.log("‚ö†Ô∏è Fonts directory not found, skipping...");
        }

    // 4Ô∏è‚É£ public ÎîîÎ†âÌÜ†Î¶¨ ÏóÖÎ°úÎìú (Ïù¥ÎØ∏ÏßÄ, Ìè∞Ìä∏ Îì±)
    if (fs.existsSync(publicDir)) {
        await uploadDirectory(publicDir, "");
    }

    // 5Ô∏è‚É£ CDN Ï∫êÏãú Î¨¥Ìö®Ìôî
    await invalidateCloudFront();

    console.log("üéâ S3 ÏóÖÎ°úÎìú Î∞è CDN Î¨¥Ìö®Ìôî ÏôÑÎ£å!");
}

main().catch((err) => {
    console.error("‚ùå Deployment failed:", err);
    process.exit(1);
});


// #!/usr/bin/env node
//
// const { S3Client, PutObjectCommand, ListObjectsV2Command, DeleteObjectCommand } = require('@aws-sdk/client-s3');
// const { CloudFrontClient, CreateInvalidationCommand } = require('@aws-sdk/client-cloudfront');
// const fs = require('fs');
// const path = require('path');
// const mime = require('mime-types');
//
// // AWS ÏÑ§Ï†ï
// const s3Client = new S3Client({ region: 'ap-northeast-2' });
// const cloudfrontClient = new CloudFrontClient({ region: 'ap-northeast-2' });
//
// const BUCKET_NAME = 'togather-static-assets';
// const CLOUDFRONT_DISTRIBUTION_ID = 'E15ZDIW40YBVEN';
//
// async function uploadDirectory(localDir, s3Prefix = '') {
//     console.log(`üöÄ Ï†ïÏ†Å ÏûêÏÇ∞ ÏóÖÎ°úÎìú ÏãúÏûë: ${localDir} -> s3://${BUCKET_NAME}/${s3Prefix}`);
//
//     const files = getAllFiles(localDir);
//     const uploadPromises = files.map(file => uploadFile(file, localDir, s3Prefix));
//
//     await Promise.all(uploadPromises);
//     console.log(`‚úÖ ${files.length}Í∞ú ÌååÏùº ÏóÖÎ°úÎìú ÏôÑÎ£å`);
// }
//
// function getAllFiles(dirPath, arrayOfFiles = []) {
//     const files = fs.readdirSync(dirPath);
//
//     files.forEach(file => {
//         const fullPath = path.join(dirPath, file);
//         if (fs.statSync(fullPath).isDirectory()) {
//             getAllFiles(fullPath, arrayOfFiles);
//         } else {
//             arrayOfFiles.push(fullPath);
//         }
//     });
//
//     return arrayOfFiles;
// }
//
// async function uploadFile(filePath, baseDir, s3Prefix) {
//     const relativePath = path.relative(baseDir, filePath);
//     // Windows Í≤ΩÎ°ú Íµ¨Î∂ÑÏûê(\\)Î•º Ïõπ Í≤ΩÎ°ú Íµ¨Î∂ÑÏûê(/)Î°ú Î≥ÄÌôò
//     const normalizedPath = relativePath.replace(/\\/g, '/');
//     const s3Key = s3Prefix ? `${s3Prefix}/${normalizedPath}` : normalizedPath;
//
//     const fileContent = fs.readFileSync(filePath);
//     const contentType = mime.lookup(filePath) || 'application/octet-stream';
//
//     const command = new PutObjectCommand({
//         Bucket: BUCKET_NAME,
//         Key: s3Key,
//         Body: fileContent,
//         ContentType: contentType,
//         CacheControl: getCacheControl(filePath),
//     });
//
//     try {
//         await s3Client.send(command);
//         console.log(`  ‚úÖ ${s3Key}`);
//     } catch (error) {
//         console.error(`  ‚ùå ${s3Key}: ${error.message}`);
//     }
// }
//
// function getCacheControl(filePath) {
//     // Ï†ïÏ†Å ÏûêÏÇ∞ÏùÄ 1ÎÖÑ Ï∫êÏãú
//     if (filePath.includes('_next/static/')) {
//         return 'public, max-age=31536000, immutable';
//     }
//     // Ïù¥ÎØ∏ÏßÄÎäî 1ÎÖÑ Ï∫êÏãú
//     if (filePath.match(/\.(jpg|jpeg|png|gif|webp|avif|svg)$/)) {
//         return 'public, max-age=31536000, immutable';
//     }
//     // Ìè∞Ìä∏Îäî 1ÎÖÑ Ï∫êÏãú
//     if (filePath.match(/\.(woff|woff2|ttf|otf)$/)) {
//         return 'public, max-age=31536000, immutable';
//     }
//     // Í∏∞Î≥∏ 1ÏãúÍ∞Ñ Ï∫êÏãú
//     return 'public, max-age=3600';
// }
//
// async function invalidateCloudFront() {
//     console.log('üîÑ CloudFront Ï∫êÏãú Î¨¥Ìö®Ìôî Ï§ë...');
//
//     const command = new CreateInvalidationCommand({
//         DistributionId: CLOUDFRONT_DISTRIBUTION_ID,
//         InvalidationBatch: {
//             CallerReference: `static-assets-${Date.now()}`,
//             Paths: {
//                 Quantity: 1,
//                 Items: ['/*']
//             }
//         }
//     });
//
//     try {
//         const result = await cloudfrontClient.send(command);
//         console.log(`‚úÖ CloudFront Î¨¥Ìö®Ìôî ÏôÑÎ£å: ${result.Invalidation.Id}`);
//     } catch (error) {
//         console.error(`‚ùå CloudFront Î¨¥Ìö®Ìôî Ïã§Ìå®: ${error.message}`);
//     }
// }
//
// async function main() {
//     try {
//         // .next ÎîîÎ†âÌÜ†Î¶¨ Ï†ÑÏ≤¥ Íµ¨Ï°∞ ÌôïÏù∏
//         const nextDir = path.join(__dirname, '..', '.next');
//         console.log('üîç .next ÎîîÎ†âÌÜ†Î¶¨ Íµ¨Ï°∞ ÌôïÏù∏ Ï§ë...');
//
//         if (fs.existsSync(nextDir)) {
//             const nextContents = fs.readdirSync(nextDir);
//             console.log('üìÅ .next ÎîîÎ†âÌÜ†Î¶¨ ÎÇ¥Ïö©:', nextContents);
//         }
//
//         // .next/static ÎîîÎ†âÌÜ†Î¶¨ ÏóÖÎ°úÎìú (Next.js Ï†ïÏ†Å ÏûêÏÇ∞)
//         const staticDir = path.join(__dirname, '..', '.next', 'static');
//         if (fs.existsSync(staticDir)) {
//             console.log('üì¶ Next.js Ï†ïÏ†Å ÏûêÏÇ∞ ÏóÖÎ°úÎìú Ï§ë...');
//             await uploadDirectory(staticDir, '_next/static');
//         }
//
//         // .next/server ÎîîÎ†âÌÜ†Î¶¨ ÏóÖÎ°úÎìú (SSR Í¥ÄÎ†® ÏûêÏÇ∞)
//         const serverDir = path.join(__dirname, '..', '.next', 'server');
//         if (fs.existsSync(serverDir)) {
//             console.log('üñ•Ô∏è Next.js ÏÑúÎ≤Ñ ÏûêÏÇ∞ ÏóÖÎ°úÎìú Ï§ë...');
//             await uploadDirectory(serverDir, '_next/server');
//         }
//
//         // .next/standalone ÎîîÎ†âÌÜ†Î¶¨ ÏóÖÎ°úÎìú (standalone ÎπåÎìú Ïãú)
//         const standaloneDir = path.join(__dirname, '..', '.next', 'standalone');
//         if (fs.existsSync(standaloneDir)) {
//             console.log('üì¶ Next.js standalone ÏûêÏÇ∞ ÏóÖÎ°úÎìú Ï§ë...');
//             await uploadDirectory(standaloneDir, '_next/standalone');
//         }
//
//         // .next/cache ÎîîÎ†âÌÜ†Î¶¨ ÏóÖÎ°úÎìú (Ï∫êÏãú ÌååÏùºÎì§)
//         const cacheDir = path.join(__dirname, '..', '.next', 'cache');
//         if (fs.existsSync(cacheDir)) {
//             console.log('üíæ Next.js Ï∫êÏãú ÏûêÏÇ∞ ÏóÖÎ°úÎìú Ï§ë...');
//             await uploadDirectory(cacheDir, '_next/cache');
//         }
//
//         // .next/static/chunks ÎîîÎ†âÌÜ†Î¶¨ ÌôïÏù∏ Î∞è ÏóÖÎ°úÎìú
//         const chunksDir = path.join(__dirname, '..', '.next', 'static', 'chunks');
//         if (fs.existsSync(chunksDir)) {
//             console.log('üß© Next.js chunks ÏûêÏÇ∞ ÏóÖÎ°úÎìú Ï§ë...');
//             await uploadDirectory(chunksDir, '_next/static/chunks');
//         }
//
//         // public ÎîîÎ†âÌÜ†Î¶¨ ÏóÖÎ°úÎìú (Ïù¥ÎØ∏ÏßÄ, Ìè∞Ìä∏ Îì±)
//         const publicDir = path.join(__dirname, '..', 'public');
//         if (fs.existsSync(publicDir)) {
//             console.log('üìÅ Public ÏûêÏÇ∞ ÏóÖÎ°úÎìú Ï§ë...');
//             await uploadDirectory(publicDir, '');
//         }
//
//         // CloudFront Ï∫êÏãú Î¨¥Ìö®Ìôî
//         await invalidateCloudFront();
//
//         console.log('üéâ Ï†ïÏ†Å ÏûêÏÇ∞ CDN Î∞∞Ìè¨ ÏôÑÎ£å!');
//         console.log('üìã ÏóÖÎ°úÎìúÎêú ÏûêÏÇ∞ ÌôïÏù∏:');
//         console.log('  - Next.js Ï†ïÏ†Å ÏûêÏÇ∞: /_next/static/*');
//         console.log('  - Next.js ÏÑúÎ≤Ñ ÏûêÏÇ∞: /_next/server/*');
//         console.log('  - Next.js standalone: /_next/standalone/*');
//         console.log('  - Next.js Ï∫êÏãú: /_next/cache/*');
//         console.log('  - Public ÏûêÏÇ∞: /*');
//     } catch (error) {
//         console.error('‚ùå Î∞∞Ìè¨ Ïã§Ìå®:', error);
//         process.exit(1);
//     }
// }
//
// if (require.main === module) {
//     main();
// }
//
// module.exports = { uploadDirectory, invalidateCloudFront };
